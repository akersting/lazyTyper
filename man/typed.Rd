% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/typed.R
\name{typed}
\alias{cast}
\alias{const}
\alias{declare}
\alias{is.typed}
\alias{is.valid}
\alias{typed}
\alias{untype}
\title{Typed Variables}
\usage{
cast(x, type, ..., env = parent.frame(), inherits = TRUE,
  .character = FALSE)

const(x, hash = FALSE, env = parent.frame(), inherits = TRUE,
  .character = FALSE)

declare(x, type, ..., env = parent.frame(), .character = FALSE)

untype(x, env = parent.frame(), inherits = FALSE, .character = FALSE)

is.typed(x)

is.valid(x)
}
\arguments{
\item{x}{variable to be typed or tested.}

\item{type}{the desired type of \code{x} (as a character string).}

\item{...}{further properties of \code{x} to guarantee (as named arguments).
The availability of additional properties depends on \code{type}. Both
positional and partial matching are used on these arguments.}

\item{env}{the environment in which to look for \code{x} / where \code{x}
should be declared. Defaults to the current environment.}

\item{inherits}{a logical value indicating if the enclosing frames of the
environment should be inspected.}

\item{.character}{a logical value indicating if \code{x} is the object to
operate on or a character vector with the names of objects to operate on.
\code{cast} always only operates on a single object.}

\item{hash}{logical. Should hashing be used to detect if a constant was
modified?}
}
\value{
For \code{untype} an invisible character vector with the names of the
  variables which were to be untyped. This allows shorthands of the following
  form for redeclaring/recasting variables: \code{cast(untype(var),
  "numeric", .character = TRUE)}.

  For \code{is.typed} either \code{TRUE} or \code{FALSE}, the former with two
  additional attributes: "type" (the type of \code{x} as a character string)
  and "properties" (a possibly empty list of additional properties of
  \code{x}).

  For \code{is.valid} either \code{TRUE} or \code{FALSE}, the latter with an
  additional attribute: "errors" (a list of condition objects indicating why
  the variable is not valid). Calling \code{is.valid} on an untyped variable
  is always an error.
}
\description{
Declare variables of or cast variables to a specific type, test typed
variables for validity and untype them again.
}
\details{
Use \code{declare} to declare one or more non-existing variable in a
  specific environment (the actual objects will NOT be created). Use
  \code{cast} to type an already existing variable.

  \code{const} is a special type of cast, which turns an existing untyped
  variable into a pseudo-constant: assigning to it (using
  \code{\link{\%<-\%}}) will fail if this would actually change the object
  and getting the value of it (using \code{\link{g}}) will fail if it was
  modified after casting \code{x} to a constant.

  \code{untype} untypes a formerly declare or casted variable. To untype a
  non-existing variable, e.g. before initialization of a declared variable or
  after calling \code{\link{remove}} with option \code{.untype = FALSE}, the
  environment in which to untype \code{x} must be explicitly given, i.e. set
  \code{inherits = FALSE}. This is because \code{untype} with \code{inherits
  = TRUE} first searches for \code{x} and then untypes it, which will either
  fail (with a warning) if a variable \code{x} does not exist anywhere or the
  wrong \code{x} will be untyped.

  \code{is.type} tests whether the variable \code{x} is typed, whereas
  \code{is.valid} tests whether the current value of \code{x} is valid given
  it type.
}
\examples{
declare(var, "character", length = 2)
var \%<-\% .(letters[1:2])

\dontrun{
var \%<-\% c("a", "b", "c")  # error: wrong length}

}
\seealso{
\code{\link{\%<-\%}} and \code{\link{\%<-s\%}} for securely
  assigning to a typed variable, \code{\link{g}} for securely getting the
  value of a typed variable, \code{\link{remove}}  for a replacement for base
  \code{\link[base]{remove}} with support for typed variables
}

